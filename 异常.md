#  7月19号

## 异常

![Exception](C:\Users\Admin\Desktop\Java Notes\pic\3.jpg)

ClassCastException

- 常见的异常类型

  ```java
  		String s="123你好";
  		int i=Integer.parseInt(s);//java.lang.NumberFormatException
  		
  		Object obj1="123";
  		Easy e1=(Easy)obj1;//java.lang.ClassCastException
  		
  		TreeSet set=new TreeSet();
  		set.add("123");
  		set.add(12.2);//java.lang.ClassCastException
  		String str="123";
  		str.substring(4);//java.lang.StringIndexOutOfBoundsException
  		int[] arr= {};
  		arr[0]=12;
  		
  		List list=new ArrayList();
  		list.get(1);//java.lang.IndexOutOfBoundsException
  		Object obj=null;
  		obj.toString();//java.lang.NullPointerException
  		int a=12/0;//java.lang.ArithmeticException
  		double b=12/0.0
  ```


#### 检查性异常

- 在编码过程中必须处理的异常叫做检查性异常

  - java程序访问外部资源一般都会抛出检查性异常

  ```java
  class PriceOutOfBoundsException extends Exception {
  
  	public PriceOutOfBoundsException() {
  		super();
  		// TODO Auto-generated constructor stub
  	}
  
  	public PriceOutOfBoundsException(String message) {
  		super(message);
  		// TODO Auto-generated constructor stub
  	}
  	
  }
  ```

  - 一个方法中可能会抛出异常,使用throws声明抛出的异常类型

    ```java
    public void checkPrice(double price) throws PriceOutOfBoundsException {
    		if(price<0||price>=100000) {
    			throw new PriceOutOfBoundsException("price of "+price);
    		}
    }
    ```


#### 运行时异常

- 在程序运行过程中才会抛出的异常叫做运行时异常

  ```java
  
  class GradeOutOfBoundsException extends RuntimeException {
  
  	public GradeOutOfBoundsException() {
  		super();
  		// TODO Auto-generated constructor stub
  	}
  
  	public GradeOutOfBoundsException(String message) {
  		super(message);
  		// TODO Auto-generated constructor stub
  	}
  	
  }
  ```

- 一个方法中抛出运行时异常，不需要明文定义

  - 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过

  ```
  public void checkGrade(double grade) {
  		if(grade<0||grade>=100) {
  			throw new GradeOutOfBoundsException();
  		}
  	}
  ```

  ```
  //所有的RuntimeExceptionn的子类都是运行时异常
  //Exception下除了RuntimeException的子类之外其他子类都是检查性异常
  ```

- try...catch... finally...

  ```java
  		//try将正常的代码尝试运行
  		//catch如果抛出了指定类型的异常,执行的方案
  		//finally不管是否抛出了异常都会执行的代码
  		File file;
  		FileInputStream fis=null;
  		try {
  			file=new File("D:\\local\\test.java");
  			fis=new FileInputStream(file);
  			//FileNotFoundException
  			//处理异常			
  		}catch(FileNotFoundException e) {
  			//try块抛出异常后, 处理的预备方案
  			file=null;
  			fis=null;
  			e.printStackTrace();
  		}catch(NullPointerException e){
  			//多个catch只会运行一个
  			}catch(StringIndexOutOfBoundsException|ArrayIndexOutOfBoundsException e){
  			//一个catch声明捕捉多种异常
  		}catch(Exception e) {
  			//范围大的异常的catch放在后面
  		}finally {
  			if(fis!=null) {
  				try {
  					fis.close();
  				} catch (IOException e) {
  					// TODO Auto-generated catch block
  					e.printStackTrace();
  				}
  			}
  		}
  ```

#### 重写方法的异常规定

```java
class A{
	public void test() throws NullPointerException {}
}

class B extends A {
    //重写的方法只能抛出范围更小的异常
	//对于检查性异常，不能抛出更多个异常
//	public void test() throws Exception {}
}
```

## try catch finally 中的 return

在一个方法中可以返回多个return

```java
public static String test() {
		try {
			int i=12/0;
			return "ok";
		}catch(Exception e) {
			return "catch";
		}finally {
			return "over";//有多个return时,最后一次return生效
		}
	}
```

