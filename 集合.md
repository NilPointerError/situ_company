# 7月18号

## 字符串两个工具类(StringBuffer、StringBuilder)
### FAQ

为什么要有这两个工具类？

解决在拼接字符串过程中出现的中间量
怎么解决?

使用一个可扩容数组来保持所有的字符
怎样扩容?

默认情况,给与16长度字符数组初始化
不断添加,如果所需要的空间>当前分配的空间
就需要扩容扩多大 

原容量*2+2;
如果扩容后的容量还不满足,要多大给多大
新的容量就等于最小所需容量

### 工具类的使用

```java
StringBuffer strb=new StringBuffer();
StringBuilder strbu=new StringBuilder();
for(int i=97;i<123;++i) {
    strb.append((char)i);
    //把字符放在数组中统一赋值，减少字符串常量池中常量存储
}
System.out.println(strb.toString());//['a','b','c'...'z']
```
### 两者区别
> StringBuffer是线程安全，运行速度较慢  
StringBuilder是非同步的，多线程运行，速度比StringBuffer快，线程不安全
## 集合
### 集合框架

- Iterable    可迭代

- Collection

- List Queue Set

  ![](C:\Users\Admin\Desktop\Java Notes\pic\837161_1488616442711_250E74268F38A4202D8C30E4329DEBCC.png)
  
  ![img](https://uploadfiles.nowcoder.com/images/20160801/740942_1470042423855_86F5A9F9F791DD7EA7C96F158F0FEA87)

![img](https://uploadfiles.nowcoder.com/images/20200501/9374535_1588304835759_DB1DF40A990BAEEF656C3ECA8B84B6E9)

### List

#### ArrayList

```   
//使用Object数组来保持数据,解决类型问题
//使用数组扩容解决数量问题
//默认容量10
//扩容 原长度+原长度/2;
```
- 声明
```java
List list = new ArrayList();
```
- 添加
```java
list.add("hello");
list.add(12)
list.add(0, 'a');
list.add(0, 'b');
list.add(0, 'c');
list.add(0, 'd');
```
- 更改
```
list.set(0, "kk");
```
- 删除
```
list.remove(12)//删除下标为12的元素
list.remove(Integer.valueOf(12))//删除数值为12的Integer类型的元素
```
- 遍历
```java
//1;
Iterator it=list.iterator();
Object obj;
while(it.hasNext()) {
	obj=it.next();
	System.out.println(obj);
}*/
//2;
for(int i=0;i<list.size();++i) {
	System.out.println(ls1.get(i));
}
```

#### LinkedList

```   java
//LinkedList使用双向链表
list.get(1);//获取元素,首先判断哪一段开始检索能更快的找到元素
//遍历获取节点,返回节点中记录的元素
list.set(1, "李四");//找到下标节点,将节点中的item重新指向
```

#### 两者区别
```java
//ArrayList  和 LinkedList
//1实现的存储方式
//2检索方式
//3ArrayList 查找快,增删慢,LinkedList检索慢,增删快
```
#### Vector

Vector是线程安全的ArrayList，在内存中占用连续的空间。初始时有一个初始大小，当数据条数大于这个初始大小后会重写分配一个更大的连续空间。如果Vector定义为保存Object则可以存放任意类型

### Set

Set集合不能保存重复数据
Set存储值是无序的(存的顺序和取的顺序是不一样的)

#### HashSet
HashSet允许存放null  

存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得

- 添加
```java
Set set = new HashSet();
set.add("hello");
set.add(new String("你好"));
set.add(new String(new char[]{'你','好'}));
set.add("你好");//值被覆盖
set.add(null);
```
- 查找
```java
System.out.println(set.contains("hello"));//true
```
- 遍历
```java
Iterator it = set.iterator();
while(it.hasNext()) {
		System.out.println(it.next());
}
System.out.println("-------------");
for(Object obj:set) {
	System.out.println(obj);
}
```

#### TreeSet

使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。

```java
    //TreeSet tset=new TreeSet();
	//排序集合
		//不能存重复数据
		//Treeset中不可以放null值
		//Treeset底层是使用TreeMap实现的,底层也是红黑树
//		tset.add(null);
//		tset.add("张三");
//		tset.add(12.3);
//		for(Object obj:tset) {
//		System.out.println(obj);
//		}
```
#### LinkedHashSet

继承于HashSet、又基于 LinkedHashMap 来实现，按添加顺序排序

### Map

#### HashMap
//数组加链表存储数据  红黑树

 不按插入顺序排序，按照哈希值排序。所以无序。

在Java中，HashMap是通过链地址法解决哈希冲突的

  - 添加
```java
Map map=new HashMap();
map.put("aaa","张三");
map.put("bbb", "张12");
map.put("ccc", "张34");
map.put("ddd", "张3456");
map.put(null,null);
map.put("ddd",null);
map.put(null,1);
```
  - 获取所有的键名的集合  
    
    Set keys=map.keySet();
    
  - 获取所有的值  
    
    Collection values=map.values();
    
  - 查找  
```java
  map.containsKey("aaa");
  map.containsValue("张三");
```
  - 删除  
    
    map.remove("bbb");

#### TreeMap

```java
    TreeMap tmap=new TreeMap();
	tmap.put("aaa",null);
	tmap.put("bbb",null);//treemap的key不能是null
```
#### Hashtable

```java
Hashtable中的key和value都不能为null，有序的
Hashtable table=new Hashtable();
		
//		table.put(null, "");
//		table.put("hello",null);

        int[] arr= {1,2,3,4,5};
		int[] arr2= new int[20];
		System.arraycopy(arr, 0, arr2, 17, arr.length);
		System.out.println(Arrays.toString(arr2));
```

hashMap在单线程中使用大大提高效率，在多线程的情况下使用hashTable来确保安全。hashTable中使用synchronized关键字来实现安全机制，但是synchronized是对整张hash表进行锁定即让线程独享整张hash表，在安全同时造成了浪费。concurrentHashMap采用分段加锁(segment)的机制来确保安全

#### hashcode

hashCode方法本质就是一个哈希函数，这是Object类的作者说明的。Object类的作者在注释的最后一段的括号中写道：将对象的地址值映射为integer类型的哈希值。但hashCode()并不完全可靠的，有时候不同的对象他们生成的hashcode也会一样，因此hashCode()只能说是大部分时候可靠。

因此我们也需要重写equals()方法，但因为重写的equals()比较全面比较复杂，会造成程序效率低下，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。因此，正常的操作流程是先用hashCode()去对比两个对象，如果hashCode()不一样，则表示这两个对象肯定不相等，直接返回false,如果hashCode()相同，再对比他们的equals()。

综上所述：

equals()相等的两个对象hashCode()一定相等。

hashCode()相等的两个对象equal()不一定相等。

## 问答

```
//用过集合没有?
//用过哪些集合? List Set Map
//这些集合用在哪些场景?
//List 用在有序，元素可重复的场合
//Set用在不需要知道顺序，查找权限
//Map用在传递前端的值，需要键值对
```

## 泛型
> 广泛的数据类型,允许使用时再来规范的数据类型
>
> ​       
参数化类型 将类型作为参数传入到方法中 创建集合时可以指定传入元素

```java
	public static final <R extends List> R test2(R r) {
		//在方法中指定泛型  规范类型的范围
		return null;
	}
```
