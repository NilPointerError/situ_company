## 线程

### 进程和线程

进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础

线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务

### 实现线程

Thread通过实现Runnable接口，子类通过继承Thread重写run()方法来实现线程，Thread中run()是空方法。

继承Thread类

```java
public class MyThread extends Thread{  
    public void run(){
    	System.out.println(Thread.currentThread().getName()+"----"+i);
    }   
    
    public static void main(String[] args) {
    	Thread t = new MyThread();
        t.start();
    }
}
```

匿名类的实现

```java
Thread t1=new Thread(){
	@Override
	public void run(){
		demo.test1();
	}
};

Thread t2=new Thread(){
	@Override
	public void run(){
		demo.test1();
	}
};
t1.start();
t2.start();
```

实现Runnable接口

```java
public class MyRunnable implements Runnable{
    
    private StringBuffer strb=new StringBuffer();//线程安全的，结果为2000
    //private StringBuilder strb=new StringBuilder();//线程不安全的，结果小于2000
    //多个线程可能在同一时间添加在数组中
    public void run(){
    	for(int i=0;i<1000;++i){
            strb.append(1);
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
		//定义了一个任务,由两个线程执行
        //多个线程可共享runnable中的数据
        MyRunnable r1=new MyRunnbale();
        Thread t1=new Thread(r1);
        Thread t2=new Thread(r1);
        t1.start();
        t2.start();
        Thread.sleep(3000);//主线程睡眠3秒，确保两个分线程执行完成
        System.out.println(r1.strb.length());
    }
    
}
```

Callable

使用线程池创建线程

### Callable和Runnable的区别?

(1)Callable规定的方法是call()，Runnable规定的方法是run()。其中Runnable可以提交给Thread来包装下，直接启动一个线程来执行，而Callable则一般都是提交给ExecuteService来执行。
(2)Callable的任务执行后可返回值，而Runnable的任务是不能返回值得
(3)call方法可以抛出异常，run方法不可以
(4)运行Callable任务可以拿到一个Future对象，c表示异步计算的结果。

### 线程常用的方法

**run: 线程执行主体**

**start:开启线程**

**join:A.join()等待A线程,让A先执行**

**yield:礼让，当前进程让出执行权**

**setName:设置线程名称**

**setPriority:设置优先级(1-10)**

优先级越高cpu调用的概率越大，但不代表一定调用

最高优先级(MAX_PRIORITY)=10

默认优先级(NORM_PRIORITY)=5

最低优先级(MIN_PRIORITY)=1

**setDaemon:设置守护线程**

```java
定义：守护线程--也称“服务线程”，在没有用户线程可服务时会自动离开。优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。
设置：通过setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的setDaemon方法。

example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。

生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。那Java的守护线程是什么样子的呢。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出。

例子程序：

thread = new Thread(this);

thread.setDaemon(true);

thread.start();

当java虚拟机中没有非守护线程在运行的时候，java虚拟机会关闭。当所有常规线程运行完毕以后，守护线程不管运行到哪里，虚拟机都会退出运行。所以你的守护线程最好不要写一些会影响程序的业务逻辑。否则无法预料程序到底 会出现什么问题。
```

**interrupt:** 通知线程终止，线程不会立即终止  实例方法

- interrupt() 方法 —> 发起线程中断请求，但只是请求，并不会真的把线程给中断，实际上是把线程的中断标识设置为了true；
- isInterrupted()方法 —> 判断线程的中断标识是否为true
- interrupted() 方法 —> **返回调用线程的中断标志位的状态，并将中断标志位置为false**   静态方法

**stop:终止线程**  实例方法

**isAlive:判断是否处于活动状态**

**sleep:休眠**  静态方法

**currentThread:获取当前线程对象,从0开始**  静态方法

### 线程安全

#### 关键字synchronized

概念

同步方法

```java
//定义同步方法，保证线程安全
public synchronized void test(){ }
//synchronized修饰的普通方法的锁对象是this    
public synchronized static void test(){}
//修饰的静态方法锁对象是当前类对象 .class
```

synchronized修饰方法，重写时synchronized不是强制继承的

```java
class Demo{
    public synchronized void test(){
        System.out.println("test1");
        try {
        	Thread.sleep(3000);
        } catch(InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class Demo2 extends Demo{
    
    @Override
    public void test1(){
		System.out.println("test1");
        try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
    
}
```

同步代码块

```java
public static void test(){
    //以Easy类为对象
    synchronized (Easy.class) {}
}
```

### wait notify notifyAll

```java
public class Easy{
    Object obj = new Object();
    static Easy easy=new Easy();
    
    public void test(){
    	synchronized (obj){
           try {
				System.out.println(Thread.currentThread().getName()+"进去了");
				obj.wait();//必须以该对象调用的同步代码块中调用
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}         
        } 
    }
    
    public void test2() {
    	synchronized(obj) {
			try {
				Thread.sleep(5000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("让锁对象放出一个线程");
			obj.notify();
		} 
    }
    
    public static void main(String[] args){
		Thread t=new T11();
    	t.start();
        easy.test();
    }
}
class T11 extends Thread{
    
    public void run() {
    	Easy.easy.test2();
    }
    
}


```

### 线程的生命周期

线程的状态：新建、就绪、运行、堵塞、死亡

![image-20220804190053215](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220804190053951.png)

### 线程池

Executors类提供了四种不同的线程池：newCachedThreadPool,newFixedThreadPool,newScheduledThreadPool,newSingleThreadExecutor

#### newCachedThreadPool

创建一个可缓存的无界限先程池，该方法无参数。当线程池中的线程空闲时间超过60s则会自动回收该线程，当任务超过线程池的线程数则创建新线程。线程池的大小上限为Integer.MAX_VALUE，可看做是无限大

```java
public static void main(String[] args){
    newCachedThreadPool();
}

public static void newCachedThreadPool(){
    ExecutorService ex=Executors.newCachedThreadPool();
    Runnable r=new Runnable() {
      
    	public void run(){
            System.out.println(Thread.currentThread().getName());
            Thread.sleep(100);
        }  
    };
    
    for(int i=0;i<10;i++){
        ex.execute(r);
        Thread.sleep(50);
    }
    
}
```

![image-20220808210559594](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220808210559594.png)

#### newFixedThreadPool

创建一个固定大小的线程池，该方法可指定线程池的固定大小，对于超出的线程会在LinkedBlockingQueue队列中等待。

```java
public static void main(String[] args){
	new newFixedThreadPool();
}
public static void newFixedThreadPool() {
    ExecutorService es=Executors.newFixedThreadPool(5);
    Runnable r=new Runnable(){
        public void run(){
            System.out.println(Thread.currentThread().getName());
            Thread.sleep(100);
        }
    };
    for(int i=0;i<10;i++){
        es.execute(r);
    }
}
```

#### newScheduledThreadPool

创建一个可定时执行或周期执行任务的线程池，该方法可指定线程池的核心线程个数。

#### newSingleThreadExecutor

创建只有一个线程的线程池，该方法无参数，所有任务都保存队列LinkedBlockingQueue中，等待唯一的单线程来执行任务，并保证所有任务按照指定顺序执行。

#### ThreadPoolExecutor

```java
package learn1;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class Easy5 {

	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		ExecutorService es = new ThreadPoolExecutor(2,//corePoolSize
                                                    4,//maximumPoolSize
                                                    20,//keepAliveTime 
                                                    TimeUnit.MILLISECONDS,//unit 空间线程存活时间单位 
                                                    new SynchronousQueue<Runnable>(),//workQueue
													Executors.defaultThreadFactory(),//threadFactory
                                                    new Easy5.MyRejectedExecutionHandler());//拒绝策略handler
			Runnable r = new Runnable() {
				@Override
				public void run() {
					System.out.println(Thread.currentThread().getName() + "------");
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			};
			Callable call= new MyCall();
//			for(int i=0;i<11;i++) {
//				es.execute(r);
//			}
			for(int i=0;i<5;i++) {
				Future fut=es.submit(call);
				//fut.cancel(true);//取消fut，后面再调fut就无法使用,返回值是false
				Object obj=fut.get();
				System.out.println(obj);
			}

		}


	static class MyRejectedExecutionHandler implements RejectedExecutionHandler {

		@Override
		public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
			executor.execute(r);
			int size = executor.getQueue().size();
			System.out.println(size);
		}

	}
}

class MyCall implements Callable<String>{

	@Override
	public String call() throws Exception {
		// 相对于run来说有了返回值且又抛出异常
		//callable 的泛型就是方法call的返回值
		System.out.println("---线程开始");
		String fd="nihao";
		Thread.sleep(3000);
		return fd;
	}
	
}

/*
一般我们创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但种模式下如果出现任务队列已满且线程池创建的线程数达到你设置的最大线程数时，这时就需要你指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，来处理线程池"超载"的情况。
ThreadPoolExecutor自带的拒绝策略:
AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；
CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行；
DiscardOledestPolicy策略：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的，马上要被执行的那个任务，并尝试再次提交；
DiscardPolicy策略：该策略会默默丢弃无法处理的任务，不予任何处理。当然使用此策略，业务场景中需允许任务的丢失

也可以自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略
*/





```

## 各种锁

### synchronized与Lock

### 悲观锁与乐观锁

### 自旋锁

### 关键字volatile

被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。

### 守护线程

指令重排
