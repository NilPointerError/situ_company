# 7月12号

## 循环操作
- for
- while
- do...while
- break;
- countinue;
## 定义方法
- 结构
- 返回值类型
    - void
    - return
        - 特性
    - 参数
        - 可变参数
            ```java
            //数量可变，类型不可变
	        //一个方法中最多有一个可变参数，并且可变参数必须放在参数列表最后
            static void method(double... i) {
		        System.out.println(i.length);
		        System.out.println(i[0]);
		        System.out.println(i[1]);
            }
            ```
## 面向对象
    //四种访问权限修饰符
    //public protected default private
    //public 公共的
    //protected 
    //default 在本包下访问得到
    //private 私有的


​	//本包下的类默认可以访问本包下的所有类
​	//所有的类默认引入java.lang包
​	
​	//在类文件中只能有一个public类，并且这个类的类名必须和文件名一致
​	//main方法必须写在public类中

- 类和对象
    - 声明类
    - 实例化对象
        - 对象属性赋值
        - 调用对象中的方法
    - 抽象
## 面向对象的特征
- 类之间的三种关系

    - 依赖关系 use-a   一个类的方法需要操控另一个类的对象
    - 聚合关系 has-a   一个类的对象包含另一个类的对象
    - 继承关系 is-a
    
- 封装

    - 将属性私有化，公共访问方法
    - getter/setter
    
- 继承
    - extends  
        ```java
        //使用extends标注继承父类
        //B子类  A父类
        //子类继承父类,子类中就具有父类中定义好的属性和方法
        //实现了代码的复用
        class B extends A {
            void test() {
                System.out.print(surname);
        //		System.out.println(money);
            }
        }
        ```
        ![](C:\Users\Admin\Desktop\Java Notes\pic\1.png)
        
    - 构造方法
        - //构造方法名和类名一致
        - //作用：初始化对象，准备资源
        - //每个类，系统会自动提供一个无参构造方法
        - //一旦自定义了构造方法，系统提供的默认构造方法就不存在了
        - super
            - 可以使用super调用父类中的属性
            - 子类中的构造方法第一行，必须调用父类的构造方法
            - 子类中的构造方法默认第一行调用父类的无参构造方法
        - this
        - java中既允许单继承，也可以多重继承
        - java中所有类的父类是Object
>//子类对父类中继承过来的方法进行重新定义--方法重写
    //父类中的方法不适应当前业务
	//必须是子类重写父类中的方法
	//方法名必须一样
	//返回值类型必须一样
	//参数列表必须一样
	//访问权限可以变大（更开放）
- 多态
    - 继承 可以向上转型 重写
    - 在程序运行过程中，一个父类的指针执行的方法，可能会出现多种形态
## 封装

## final

```java
	public static final <R extends List> R test2(R r) {        
    //在方法中指定泛型  规范类型的范围        
    	return null;    
    }
```

1. 在构造函数中赋值
2. 初始化赋值


    //关键字final
    //final修饰的类不可以被继承
    //用final修饰的量不能重新赋值
    //final修饰方法不能被重写

## 继承
- 类继承类

- 类继承抽象类
    - 抽象类相互继承
    - //抽象类中可以定义抽象方法
	- //有该方法的定义，但是没有实现，没有方法体
	- //继承抽象类的实体类必须实现抽象类中的抽象方法
	
	**abstract是用来修饰类和方法的：**
	
	  **1. 修饰方法：abstract不能和private、final、static共用。**
	
	  **2. 修饰外部类：abstract不能和final、static共用。（外部类的访问修饰符只能是默认和public）**
	
	  **3. 修饰内部类：abstract不能和final共用。（内部类四种访问修饰符都可以修饰）**
	
- 类实现接口
```java
    public interface ICar {
        //接口中的属性是常量
        //接口中的量默认是常量  默认使用public static final
        //常量名要全部大写
        int MAX=12;
        
        
        //接口中所有的方法都是抽象方法
        //接口中定义抽象方法可以不写abstract
        //接口中定义的方法都是用public abstract来修饰的
        void run();
        //接口中可以拥有default修饰的实体方法
        //实例(对象)可以调用的方法
        //访问权限为public
        default void test() {}
        
    }

    //类通过implements实现接口
    //实现接口的类必须实现接口中定义的方法

    //接口继承允许多继承 ****
    interface IEasy extends ICar,ITest {
        
    }
```
- 接口继承接口
- 方法重写
    - 访问权限修饰符注意事项
    - 异常的注意事项
- 方法重载
    - 在一个类中，方法名一样即为重载
- 构造方法注意事项
- 超级父类Object
## 多态
- 继承 可以向上转型 重写
- 在程序运行过程中，一个父类的指针执行的方法，可能会出现多种形态
## 代码块

1. 父类静态代码块，父类静态成员变量（同级，按代码顺序执行）
2. 子类静态代码块，子类静态成员变量（同级，按代码顺序执行）
3. 父类普通代码块，父类普通成员变量（同级，按代码顺序执行）
4. 父类构造方法
5. 子类普通代码块，子类普通成员变量（同级，按代码顺序执行）
6. 子类构造方法

```java
public class Demo extends A {
	
	static {
		System.out.println("D----静态代码块");
	}
	
	{
		//每次在运行构造方法前会运行普通代码块
		System.out.println("D---代码块");
	}
	
	Demo() {
		System.out.println("D------");
	}

	
	public static void main(String[] args) {
		new Demo();
	}
	
}

class A {
	static {
		new Demo();
		System.out.println("A----静态代码块");
	}
	
	{
		//每次在运行构造方法前会运行普通代码块
		System.out.println("A---代码块");
	}
	
	A() {
		System.out.println("A------");
	}

}
```
运行结果如图所示：

<img src="C:\Users\Admin\Desktop\Java Notes\pic\image-20220721212510360.png" alt="image-20220721212510360" style="zoom: 67%;" />









