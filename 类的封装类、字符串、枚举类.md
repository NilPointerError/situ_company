# 7月15号
## 类的强制类型转换

![img](https://uploadfiles.nowcoder.com/images/20190412/242025553_1555068065653_1F768A0737B2E9FBB49649C7465CBFCE)

```java
A a = new A();
A aa = new B();
Object obj=new B();
//只有确定当前对象是本类型或本类的子类对象才能转换成功
//B b=(B)a; 转换不成功
B b=(B)aa;
b = (B)obj;
a=(B)obj;
class A{}
class B extends A{

}
```
## 基本数据类型的封装类型
- 装箱&拆箱
```java
		//基本数据类型--保存的是值
		//基本数据类型不是面向对象的
		//java要做到万物皆对象，提供了基本数据类型的封装类型
		//byte short int long
		//Byte Short Integer Long
		
		//float double
		//Float Double
		
		//char
		//Character
		
		//boolean
		//Boolean
		
		System.out.println(Integer.MAX_VALUE);
		//封装类型提供将字符串转为基本数值类型的方法parseInt
		int a=Integer.parseInt("12")+23;
		System.out.println(a);
		boolean bool = Boolean.parseBoolean("22");
		System.out.println(bool);

		//装箱&拆箱
		int i=12;
		Integer it=i;
		//装箱：将基本数据类型直接转换为其封装类型的对象
		it=new Integer(12);
		i=it;
		//拆箱：将封装类型的对象转换为基本类型的值的过程
		
		Short s=12;
		Short ss=23;
//		s=s+ss;
		
		//缓存机制
		//==
		Object obj=new Object();
		Object o1=new Object();
		Object o2=new Object();
		System.out.println("o1,o2"+(o1==o2));
		
		Integer i1=12;
		int i2=12;
		Byte b1=12;
		System.out.println("i1,i2"+(i1==i2));
		//封装类型和基本数据类型比较是否相等，先拆箱后比较
		System.out.println("i2,b1"+(i2==b1));
		//引用类型==比较只有类型一样才能编译通过,比较是否是一个对象
//		System.out.println(i1==b1);
		
		Integer ii1=12;
		Integer ii2=12;
		System.out.println("ii1,ii2"+(ii1==ii2));
	
		ii1=128; //Integer缓存范围为byte,超出范围new 新的范围，地址不同
		ii2=128;
		System.out.println("ii1,ii2"+(ii1==ii2));

		Byte bb1=12;
		Byte bb2=12;
		System.out.println("bb1,bb2"+(bb1==bb2));
		
		Short ss1=128;
		Short ss2=128;
		System.out.println("ss1,ss2"+(ss1==ss2));
		
		long l1=12;
		Long ll1=12l;
		Long ll2=12l;
		System.out.println("ll1,ll2"+(ll1==ll2));
		
		ii1=12;
		ii2=new Integer(12);
		System.out.println("ii1,ii2"+(ii1==ii2));
		
		ii1=190;
		ii2=190;
		System.out.println("ii1,ii2"+(ii1==ii2));
```
链接：https://www.nowcoder.com/questionTerminal/d2282ec2c34a498ebc88bfb87909e11a
来源：牛客网

Float a = new Float(1.0); 这个的东西能存在，是因为Float类中有形参是float和double的两个构造器。
Double d = new Double(1.0F);这个能成立的原因是float向上转型了。
Float a = 1.0；这个东西不成立是因为浮点型的默认类型是double，而double不会自动转成float，然后再装箱。
Double d = 1.0f；不成立的原因是因为Double类中的装箱方法，只有valueOf(String s)和valueOf(double d)；装箱本身可不会自动向上转型啊。

intValue()是把Integer、Double对象类型变成int的基础数据类型；
Integer.parseInt()是把String 变成int的基础数据类型；
Integer.valueof()是把String 转化成Integer对象类型；

## 字符串

- 字符串类使用final修饰的类，不能被继承
- String 不是关键字，不是基本数据类型
- 字符串的声明
```java
	String str = "你好";
	//首先在常量池（方法区）中查找是否存在内容为"abc"的字符串对象
	//如果不存在则在常量池中创建一个"abc"的字符串对象，并让str引用该对象
	//如果存在则直接让str引用该对象
	String str2 = new String("12");
	//首先定义一个str的String类型的引用并存放在栈中
	//在字符串常量池中查看是否存在内容为"abc"字符串对象 
	//若存在则跳过这个步骤，若不存在，则在字符串常量池中创建一个内容为"abc"的字符串对象。（前三步都是在编译时完成的）
	//执行new操作，在堆中创建一个指定的对象"abc"，这里堆的对象是字符串常量池“abc”对象的一个拷贝对象。	
	//让str指向堆中“abc”这个对象（也就是存储这个对象的在堆中的地址）
```
- 字符串的拼接
```java
	str = 12+23+"你好";//35你好
	str="你好"+12+23;//你好1223
	//Object类中有个toString方法
	str="你好"+aa.toString();
	str="你好"+aa;//调用aa.toString();
```
- 字符串的判断
```java
	//使用equals()方法比较两个字符串的值是否一样
	String str1="123456";
	String str3=new String("123456");
	System.out.println(str1==str3);//false 两者内存地址不一样
	System.out.println(str1.equals(str3));//true
```
- 常量优化机制
	- 编译过程中如果出现常量运算，JVM会自动运算结果并复制
	- 非常量字符串拼接会开辟新的空间存储
	```java
	String str1="123"+"456";
	String str2="12"+"3456";
	String str3=new String("123456");
	String str4=new String("123456");
	String str5="123"+"456";
	System.out.println(str1==str2);//true
	String str6="123"+new String("456");
	String str8="123";
	String str9=str8+"456";
	final String str88="123";
	String str99=str88+"456";
	
	System.out.println(str1==str2);//true
	System.out.println(str1==str3);//false
	System.out.println(str3==str4);//false
	System.out.println(str1==str5);//true
	System.out.println(str6==str1);//false
	System.out.println((str1==str9)+"----str1==str9");//false;
	System.out.println(str1==str99);//true
	```
	
- 空指针异常的两种情况
	- null值调用方法或属性会出现空指针异常
	- 在个别方法中不允许空参数，会主动抛出空指针异常
	
- 字符串中常用的方法
	- toCharArray() 复制一个新的数组并返回
	```java
	String str="123456"+"7";
	//toCharArray复制了一个新的数组并返回
	char[] c_arr=str.toCharArray();//[1, 2, 3, 4, 5, 6, 7]
	```
	- length()字符串中字符的个数
	- substring(beginIndex,endIndex) 截取[beginIndex, endIndex)中的字符串
	```java
	String substr=str.substring(2);
	System.out.println(substr);//34567
	substr=str.substring(2,6);
	System.out.println(substr);//3456
	```
	- indexOf(String str) 从左往右找到返回第一个字符的下标，找不到返回-1
	```java
	int index=str.indexOf("34");
	System.out.println(index);//2
	index=str.indexOf("35");
	System.out.println(index);//-1
	```
	- 获取指定位置的字符
	```java
	char c=str.charAt(3);
	System.out.println(c);
	```
	- intern() 
	```
	//检查字符串常量池中是否有该内容的字符串
	//如果没有就复制一份存储到常量池中，返回常量池中的地址
	//如果已经存在，返回常量池中的地址
	
	//字符串定义出来就不能再改变，所有的字符串的处理都会返回一个新的串，不会对原串所修改
	```
	- replace(s1, s2) 把字符串中的所有s1字符串替换成s2字符串
	```java
	filename="Hello.java.txt";
	String nstr=filename.replace("a", "A");
	System.out.println(nstr);//Hello.jAvA.txt
	```
	- replaceAll(s1, s2)   s1为正则表达式
	```java
	nstr=filename.replaceAll(".", "A");
	System.out.println(nstr);AAAAAAAAAAAAAA
	```
	
	- trim()   去除字符串前后空格
	- contains(String str) 是否包括str字符串 

## 枚举类

![img](https://uploadfiles.nowcoder.com/images/20170622/6614221_1498121084973_B334BD6B2D5D0818DCF03089F7D43C28)