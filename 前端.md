# JavaWeb

## Servlet

### 关系图

![img](https://uploadfiles.nowcoder.com/images/20171024/9430388_1508834386231_FE8B1A979ADF6E3C2C114AF3F9CA693C)

### 概念

Servlet 是 Server Applet 的简称，译作“服务器端小程序”;
Servlet 程序其实就是一个按照 Servlet 规范编写的 Java 类。它具有平台独立性，可以被编译成字节码，移植到任何支持 Java 技术的服务器中运行。

继承了HttpServlet类

### 配置方式

注解、Web.xml

**loadOnStartup**：控制Servlet启动优先级

1. 它的取值必须是一个整数；
2. 当值小于 0 或者没有指定时，则表示容器在该 Servlet 被首次请求时才会被加载；
3. 当值大于 0 或等于 0 时，表示容器在启动时就加载并初始化该Servlet，取值越小，优先级越高；
4. 当取值相同时，容器就会自行选择顺序进行加载。

```java
/**
	 * 当浏览器通过get请求方式访问servlet会执行doGet方法
	 * 怎样访问到servlet 使用@WebServlet注解  做了一个映射urlPatterns = "/hello"
	 * 浏览器访问到urlPatterns后指定的路径就访问到当前servlet了
	 */
@WebServlet(urlPatterns = "/hello",loadOnStartup = 1) 
```

### Session和Cookie

#### Cookie

- 客户端浏览器保存

- 保存账号密码

- 自动登录

#### Session

- 服务器保存

  - 内存

  - 持久化
- 保存登录信息
- 基于Cookie

代码：

```java
//获取session对象 会话对象
//从第一次访问服务器开始,Tomcat服务器就会维护一个session对象
//主动注销或者超时时，session销毁
HttpSession session=req.getSession();
session.setAttribute("LOGINUSER", dUser);
Object object=session.getAttribute("LOGINUSER");

HttpSession session=req.getSession();
session.invalidate();//注销session
```

session超时设置在web.xml中的设置 

```xml
<session-config>
  	<session-timeout>60</session-timeout>  <!-- 60分钟超时 -->
</session-config>
```

### 请求转发和重定向

**转发过程：** 客户端浏览器发送http请求 → web服务器接受此请求 → 调用内部的一个方法在容器内部完成请求处理和转发动作 → 将目标资源发送给客户。   

**重定向过程：** 客户端浏览器发送http请求 → web服务器接收后发送30X状态码响应及对应新的location给客户浏览器 → 客户浏览器发现是30X响应，则自动再发送一个新的http请求，请求url是新的location地址
服务器根据此请求寻找资源并发送给客户。

```java
/**
	 * 浏览器发送请求先通过service来进行分支 判断采用get方法或post方法	
	 */
	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		
		/**
		 * 获取前端发送的参数
		 */
		String username=req.getParameter("username");
		String userpass=req.getParameter("userpass");
		req.getParameterMap();
		
		resp.getWriter().write("service method"+username+"---"+userpass);
	
		/*通过servlet跳转页面*/
		/*重定向 转发*/
		/*重定向,可以定位到外部项目,浏览器发送了两次请求*/
//		resp.sendRedirect("https://www.baidu.com");
		/*转发,只能在本项目内转发,浏览器发送了一个请求,浏览器请求的地址不会发生变化
		 * 可以访问WEB-INF下受保护资源
		 * */
		req.getRequestDispatcher("WEB-INF/other.jsp").forward(req, resp);
		
	}
```

|                      | 转发          | 重定向                                                   |
| -------------------- | ------------- | -------------------------------------------------------- |
| 跳转方式             | 服务器端转发  | 客户端转发                                               |
| 客户端发送请求次数   | 1次           | 2次                                                      |
| 客户端地址栏是否改变 | 不变          | 变                                                       |
| 是否共享request域    | 共享          | 不共享（request域中的数据丢失），必须使用session传递属性 |
| 是否共享response域   | 共享          | 不共享                                                   |
| 范围                 | 网站内        | 可以跨站点                                               |
| JSP                  | URL不可带参数 | URL可带参数                                              |
| 是否隐藏路径         | 隐藏          | 不隐藏                                                   |

**什么时候使用重定向，什么时候使用转发？**

**原则上：** 要保持request域的数据时使用转发，要访问外站资源的时候用重定向，其余随便；
**特殊的应用：**  对数据进行修改、删除、添加操作的时候，应该用response.sendRedirect()。如果是采用了request.getRequestDispatcher().forward(request,response)，那么操作前后的地址栏都不会发生改变，仍然是修改的控制器，如果此时再对当前页面刷新的话，就会重新发送一次请求对数据进行修改，这也就是有的人在刷新一次页面就增加一条数据的原因。

**转发与重定向的安全性？**

**转发安全性：** 在服务器内部实现跳转，客户端不知道跳转路径，相对来说比较安全。
**重定向安全性：** 客户端参与到跳转流程，给攻击者带来了攻击入口，受威胁的可能性较大。比如一个HTTP参数包含URL，Web应用程序将请求重定向到这个URL，攻击者可以通过修改这个参数，引导用户到恶意站点，并且通过将恶意域名进行十六进制编码，一般用户很难识别这是什么样的URL；或者指引到该网站的管理员界面，如果访问控制没有做好将导致一般用户可以直接进入管理界面。
 **重定向和转发检查列表：**
 重定向之前，验证重定向的目标URL。
 使用白名单验证重定向目标。
 如果在网站内重定向，可以使用相对路径URL。
 重定向或者转发之前，要验证用户是否有权限访问目标URL。

### Get和Post

**区别**

1.get是从服务器上获取数据，post是向服务器传送数据。

2.get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTPpost机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。

3.对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。

4.get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。（这里有看到其他文章介绍get和post的传送数据大小跟各个浏览器、操作系统以及服务器的限制有关）

5.get安全性非常低，post安全性较高。

#### Get

当浏览器通过get请求方式访问servlet会执行doGet方法,使用@WebServlet注解做了一个映射urlPatterns="\hello",浏览器访问到urlPatterns后指定的路径就访问到当前servlet了

```java
@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {	
	/**
	 * request 请求对象,将浏览器请求服务器的数据包装成request对象	
	 * 
	 * response 是服务器响应浏览器请求的回应数据的包装对象
	 * 
	 */
		resp.getWriter().write("doget methond");
	}
```

#### Post

可通过表单标签进行post请求方式

```java
/**
	 * 通过不同的请求方式访问的不同的方法
	 */
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		doGet(req, resp);
	}
```

### 生命周期

1. 默认情况下,第一次访问servlet时实例化对象,并且立即执行init方法进行初始化,可以使用loadOnStartup来控制servlet实例化对象的时机,取值越小,优先级越高
2. 请求访问servlet,有先执行service方法,service中根据请求方式不同,分别执行doget和dopost方法
3. 当服务器关闭时会销毁servlet对象,执行destroy方法

```java
public HelloServlet() {
		System.out.println("---HelloServlet实例化对象---");
	}
	
	@Override
	public void init(ServletConfig config) throws ServletException {
		System.out.println("---HelloServlet初始化---");
	}
	
	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		super.destroy();
		System.out.println("---HelloServlet销毁---");
	}
```

### 项目采取的分包方式

bean 实体层

dao 数据访问层

service 业务逻辑层

servlet 服务端小程序

util 工具包

### 域对象

#### request  

最小

#### session  

中等

#### servletcontext 

最大

### BS架构和CS架构的优缺点

⼀、B/S架构
1、什么是B/S(Browser/Server)架构?
应⽤系统完全放在应⽤服务器上, 并通过应⽤服务器同数据库服务器进⾏通信,系统界⾯是通过浏览器来展现的.
T是浏览器模式.
2、优点：
1）客户端⽆需安装，有Web浏览器即可。
2）BS架构可以直接放在⼴域⽹上，通过⼀定的权限控制实现多客户访问的⽬的，交互性较强。
3）BS架构⽆需升级多个客户端，升级服务器即可。
3、缺点：
1）在跨浏览器上，BS架构不尽如⼈意。
2）表现要达到CS程序的程度需要花费不少精⼒。
3）在速度和安全性上需要花费巨⼤的设计成本，这是BS架构的最⼤问题。
4）客户端服务器端的交互是请求-响应模式，通常需要刷新页⾯，这并不是客户乐意看到的。（在Ajax风⾏后此问题得
到了⼀定程度的缓解）

二、C/S架构
1、什么是C/S(client/Server)架构?
c/s架构分为客户端和服务器两层,⽤户在本地安装客户端软件,通过网络与服务器相互通信,最典型的应⽤有QQ聊天,微信,
⽤户只需在客户端安装应⽤软件,
实现与服务器之间的通信.
2、优点:
1）C/S架构的界⾯和操作可以很丰富。
2）安全性能可以很容易保证，实现多层认证也不难。
2）安全性能可以很容易保证，实现多层认证也不难。
3）由于只有⼀层交互，因此响应速度较快。
3、缺点：
1）适⽤⾯窄，通常⽤于局域⽹中。
2）⽤户群固定。由于程序需要安装才可使⽤，因此不适合⾯向⼀些不可知的⽤户。
3）维护成本⾼，发⽣⼀次升级，则所有客户端的程序都需要改变。

## JSP

### 概念

JSP是一种动态网页开发技术。JSP文件就是在传统的HTML文件中插入Java代码和JSP标签，后缀名.jsp

### 指令标签

#### 概念

#### page

JSP page 指令用来定义当前页面的相关属性。page 指令可以在 JSP 页面的任意位置编写，通常放在 JSP 页面的顶部。

<%@ page attribute = "value" %>

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
  isELIgnored="false" errorPage="e.jsp" pageEncoding="UTF-8" import="java.util.List,com.easy.bean.User"%>
<!--  import导入包 isELIgnored是否忽视EL表达式 errorPage为e.jsp，出现异常时跳转 -->

<%=a/0 %>
<%! int a=22; %>  <!-- 定义成员变量 -->
```

e.jsp代码

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" isErrorPage="true" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<%=exception %> <!-- 打印错误信息 -->
</body>
</html>
```

结果如下图

![image-20220728203406615](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728203406615.png)

page标签中的一些常用属性:

![image-20220728201014222](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728201014222.png)

#### include

include 指令用于在 JSP 页面引入其它内容，可以是 JSP 文件、html 文件和文本文件等，相当于把文件的内容复制到 JSP 页面。引入的文件和 JSP 页面同时编译运行。

<%@ include file="URL" %>  

```jsp
<%@ include file="in.jsp" %>   <!-- 将in.jsp代码直接复制到这个位置 -->
<%=a %>         <!-- 定义局部变量 -->
<!-- 动态jsp:include是将引入页面编译完成后,再将页面结果导入该位置 -->
<jsp:include page="in2.jsp"></jsp:include>

<%-- <%=b %> --%>  
```

in.jsp代码

```jsp
<h1 style='color:red'>${soeasy}</h1>
<%int a=12; %>
```

in2.jsp代码

```jsp
<h1 style='color:red'>${soeasy}</h1>
<%int b=12; %>
```

#### taglib

在 JSP 中，我们可以使用 taglib 指令声明并引入标签库。

<%@ taglib uri="tagliburl" prefix="tagPre" %>

uri 指定自定义标签库的存放位置；prefix 指定标签库的前缀。为了区分不同的标签库，在页面中使用标签库以对应的 prefix 开头。

### 动态标签

利用 JSP 动作可以动态地插入文件、重用 JavaBean 组件、把用户重定向到另一个页面、为 Java 插件生成 HTML 代码等。

#### forward

- \<jsp:forward\> 动作用来将请求转发到另一个页面中，请求的参数数据会被一起转发到目标页面。

- <jsp:forward page="url"/>
- page 指定需要转发文件的相对路径，且指定的文件只能是该 Web 应用中的文件。

#### include

- \<jsp:include> 动作用来在页面中引入文件，文件可以是 HTML、JSP 页面和文本文件等。通过 include 动作，我们可以多次使用同一个页面，增加了代码可重用性。例如，在页面中使用 include 动作引入头部和底部页面。
- <jsp:include page="relativeURL | <%=expression%>" flush="true" />
- page 指定引入页面的路径，flush 表示在引入文件前是否刷新缓冲区，默认为 false。

#### param

- \<jsp:param> 动作用来传递参数信息，经常和其它动作一起使用，例如 \<jsp:include> 和 \<jsp:forward>。

- <jsp: param name="param_name" value="param_value" />

- <jsp:forward page="index.jsp">

  ​        <jsp:param name="sitename" value="Easy" />

  ​        <jsp:param name="url" value="http://www.easy.net" />

  \</jsp:forward>

#### useBean

- \<jsp:useBean> 用于获取 Bean 对象。\<jsp:useBean> 首先会在指定范围内查找 Bean 对象，如果 Bean 对象不存在，则创建 Bean 对象。
- <jsp:useBean id = "name" class = "package.class" scope= "page | request | session | application" />

#### setProperty和getProperty

- \<jsp:getProperty> 动作用于获取 Bean 的属性值，\<jsp:setProperty> 动作用于设置 Bean 的属性值。

- <jsp:getProperty name = "beanName" property = "attributeName">

- <jsp:setProperty name = "beanName" property = "attributeName" value = "attributeValue"/>

- name 指定需要修改属性的 Bean 的名称；property 指定 Bean 的属性，即 Bean 类中的属性；value 是要设定的属性值

- 两种用法

  - <jsp:useBean id = "User" ... />

    <jsp:setProperty name = "User" property = "attributeName" value = "attributeValue"/>

  - <jsp:useBean id = "User" ...>

    <jsp:setProperty name = "User" property = "attributeName" value = "attributeValue"/>

    \</jsp:useBean>

- \<jsp:setProperty> 和 \<jsp:getProperty> 动作都会按照 page、request、session 和 application 的顺序依次查找指定 Bean 的实例对象，直到第一个实例被找到

### 内嵌Java代码

#### JSP脚本

格式: <% Java语句 %>

<% %>中定义的变量是局部变量，方法是局部方法。

输出list表格中的每行中的数值

```jsp
<table>
	<tr><td>ID</td><td>账号</td><td>密码</td></tr>
	<%for(User u:list){%>
		<tr><td><%=u.getId() %></td><td><%=u.getUsername() %></td><td><%=u.getUserpass() %></td></tr>
	<%
	}%>	
</table>
```

#### JSP声明语句

格式: <%! 声明语句 %>

JSP 声明会把包含的内容添加到 Servlet 类中（在任何方法之外），也就是 <%! %> 中定义的变量是成员变量，方法是成员方法。

#### JSP表达式

格式: <%= 表达式 %>

可以将 <%=表达式 %> 理解为 <% out.write(表达式) %> 的简写方式。这里需要注意，JSP 表达式不能以分号结尾。

### 九大内置对象

#### 概念

JSP 内置对象又称为隐式对象，它们由容器实现和管理。在 JSP 页面中，这些内置对象不需要预先声明，也不需要进行实例化，我们可以直接在脚本和表达式中使用。

代码实现

```jsp
<%
	List<User> list=(List)request.getAttribute("userlist");
	pageContext.setAttribute("easy", "java soeasy",PageContext.PAGE_SCOPE);
	pageContext.setAttribute("user", list,PageContext.PAGE_SCOPE);
	String str=(String)pageContext.getAttribute("easy");
	out.write(str);
%>
```

#### request

JSP request 是 javax.servlet.http.HttpServletRequest 的实例对象，主要用来获取客户端提交的数据。

request 对象提供了一系列方法，可以获取请求参数信息、表单数据、HTTP 头信息、cookie 和 HTTP 请求方法等。

![image-20220728214602358](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728214602358.png)

#### response

JSP response 是 javax.servlet.http.HttpServletResponse 的实例对象。response 对象和 request 对象相对应，主要用于响应客户端请求，将处理信息返回到客户端。

![image-20220728214651547](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728214651547.png)

#### session

JSP session 是 javax.servlet.http.HttpSession 的实例对象，主要用来访问用户数据，记录客户的连接信息。

HTTP 协议是一种无状态的协议（即不保存连接状态的协议）。每次用户向服务器发出请求，且服务器接收请求并返回响应后，该连接就被关闭了，服务器端与客户端的连接被断开。此时，服务器端不保留连接的有关信息，要想记住客户的连接信息，就用到了 session 对象。

![image-20220728214741901](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728214741901.png)

#### application

JSP application 是 javax.servlet.ServletContext 的实例对象。在服务器部署应用和项目时，Web 容器仅创建一次 ServletContext 实例，也就是说 application 设置的任何属性和值可以用于整个应用（所有 JSP 页面）。可以将 application 对象看作 Web 应用的全局变量。一般用于保存应用程序的公用数据。

application 对象在 Web 应用运行时一直存在于服务器中，非常占用资源，因此在实际开发中不推荐使用，否则容易造成内存不足等情况。

![image-20220728214853393](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728214853393.png)

#### out

JSP out 是 javax.servlet.jsp.JspWriter 的实例对象。out 对象包含了很多 IO 流中的方法和特性，最常用的就是输出内容到 HTML 中。

![image-20220728214903031](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728214903031.png)

这里的 println 与 newLine 换行指的是 HTML 代码换行，并不是页面显示的换行。页面显示换行需要在代码后面加 <br> 标签。

#### page

JSP page 的实质是 java.lang.Object 对象，相当于 Java 中的 this 关键字。page 对象是指当前的 JSP 页面本身，在实际开发中并不常用。

![image-20220728215005206](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728215005206.png)

#### pageContext

pageContext 是 javax.servlet.jsp.PageContext 的实例对象。pageContext 对象表示整个 JSP 页面，可以获取或删除四大作用于对象的任意属性

![image-20220728215027162](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728215027162.png)

#### config

JSP config 是 javax.servlet.ServletConfig 的实例对象，一般用于获取页面和 Servlet 的初始化参数。

![image-20220728215040769](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728215040769.png)

#### exception

Exception类的对象，代表发生错误的JSP页面中对应的异常对象，必须在异常界面中使用

![image-20220728215140404](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728215140404.png)

### 四大作用域

page

page作用域不是page,是context对象

request

session

application

### EL

#### 内置对象

![image-20220728220339052](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728220339052.png)

#### 访问属性

${EL表达式}

${user.name}

${param.name}相当于<%=request.getParameter('name') %>

EL表达式中如果不指定作用域,就从小的作用域开始查找,直到找到为止

#### 访问对象

#### 访问集合

#### EL运算符

##### EL算术运算符

![image-20220728220911738](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728220911738.png)

EL 的+运算符与 Java 的+运算符不一样，它无法实现两个字符串的连接运算。如果该运算符连接的两个值不能转换为数值型的字符串，则会拋出异常；反之，EL 会自动将这两个字符转换为数值型数据，再进行运算。

EL 表达式中还可以使用 ( ) 改变优先级，例如：${2+3*2} 等于 8，${(2+3)*2} 等于 10。

##### EL比较运算符

比较运算符用来实现两个表达式的比较，进行比较的表达式可以是数值型或字符串。

![image-20220728220938310](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728220938310.png)

##### EL逻辑运算符

逻辑运算符两边的表达式必须是布尔型（Boolean）变量，其返回结果也是布尔型（Boolean）

![image-20220728220955487](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728220955487.png)

##### EL其它运算符

. 和 [ ]   是 EL 中最常用的运算符，用来访问 JavaBean 中的属性和隐式对象的数据。一般情况下，.用来访问 JavaBean 属性或 Map 类型的值，[ ]用来访问数组或者列表的元素。

empty 用来判断 EL 表达式中的对象或者变量是否为空。若为空或者 null，返回 true，否则返回 false。   ${empty str1}

${条件表达式?表达式1:表达式2}

##### EL运算符优先级

![image-20220728221020119](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728221020119.png)

##### EL保留字

![image-20220728221039618](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728221039618.png)

#### 禁用EL表达式

禁用单个EL表达式\\${2+3}

禁用当前页面的EL表达式<%@ page isELIgnored="true" %>

禁用整个Web应用的EL表达式

1. <jsp-property-group>
2.  <url-pattern>*jsp</url-pattern>
3.  <el-ignored>false</el-ignored>
4. </jsp-propery-group>

### JSTL 

#### 概念

JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。

JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。

#### 下载

http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/

#### 引入

jar包、taglib 

#### 功能

代码实现

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/sql" prefix="sql" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<c:out value="hello"></c:out>
<c:set var="text" value="你好" scope="session"></c:set>

<c:forTokens items="12345123412341212" delims="3" var="str">

	${str }
</c:forTokens>

<c:set var="it" value="数字" scope="request"></c:set>
<c:choose>
	<c:when test='${it eq "数字"}'>
		这个一个数字
	</c:when>
	<c:when test='${it eq "文本"}'>
		这是一个文本
	</c:when>
	<c:otherwise>
		otherwise
	</c:otherwise>
	
</c:choose>

<sql:setDataSource driver="com.mysql.cj.jdbc.Driver"
	url="jdbc:mysql://localhost:3306/mydata?useSSL=false&characterEncoding=utf8"
	user="root"
	password="123456"
	var="ds"
	scope="request"
/>

<sql:query sql="select * from t_user" dataSource="${ds }" var="list" scope="request">
</sql:query>

<c:forEach items="${list.rows }" var="row">
	${row.username }
</c:forEach>
</body>
</html>
```



##### 核心标签

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

\<c:out>	用于在JSP中显示数据，就像<%= ... >

\<c:set>	用于保存数据

\<c:remove>标签用于移除一个变量，可以指定这个变量的作用域，若未指定，则默认为变量第一次出现的作用域。

\<c:if>标签判断表达式的值，如果表达式的值为 true 则执行其主体内容。

\<c:forEach>标签是更加通用的标签，因为它迭代一个集合中的对象。

\<c:forTokens>标签通过指定分隔符将字符串分隔为一个数组然后迭代

\<c:choose>, \<c:when>,\<c:otherwise> 标签

\<c:catch> 标签主要用来处理产生错误的异常状况，并且将错误信息储存起来。

\<c:import>标签提供了所有\<jsp:include>行为标签所具有的功能，同时也允许包含绝对URL。

##### 格式化标签

<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>

\<fmt:formatDate>标签用于使用不同的方式格式化日期。

![image-20220728222154457](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728222154457.png)

##### JSTL函数

<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>

![image-20220728222215253](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728222215253.png)

##### SQL标签

<%@ taglib prefix="sql" uri="http://java.sun.com/jsp/jstl/sql" %>

\<sql:setDataSource>标签用来配置数据源或者将数据源信息存储在某作用域的变量中，用来作为其它JSTL数据库操作的数据源。

\<sql:query>标签用来运行SQL SELECT语句，还有就是将结果存储在作用域变量中。

\<sql:update>标签用来执行一个没有返回值的SQL语句，比如SQL INSERT，UPDATE，DELETE语句

\<sql:param>标签与\<sql:query>标签和\<sql:update>标签嵌套使用，用来提供一个值占位符。如果是一个null值，则将占位符设为SQL NULL。

\<sql:transaction>标签用来将\<sql:query>标签和\<sql:update>标签封装至事务中。可以将大量的\<sql:query>和\<sql:update>操作装入\<sql:transaction>中，使它们成为单一的事务。

##### XML 标签

<%@ taglib prefix="x" uri="http://java.sun.com/jsp/jstl/xml" %>

在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的<Tomcat 安装目录>\lib下

XercesImpl.jar 下载地址： http://www.apache.org/dist/xerces/j/

xalan.jar 下载地址： http://xml.apache.org/xalan-j/index.html

### JSP生命周期

#### JSP编译 

第一次访问时，JSP容器把JSP文件翻译成Servlet类

#### JSP初始化

当容器加载JSP时，它将在处理任何请求之前调用jspInit()方法。如果您需要自定义JSP的初始化内容，可以重写jspInit()方法

#### JSP执行

此阶段表示了JSP生命周期中所有与请求相关的交互行动，直到被销毁。

JSP页面完成初始化后，JSP将会调用_jspService()方法

#### JSP销毁

关闭服务器时，JSP生命周期的销毁阶段表示从容器中删除JSP。

jspDestroy()方法等效于Servlet中的destroy()方法，如果您需要自定义JSP的销毁内容，可以重写jspDestroy()方法

## Filter

过滤器要实现 javax.servlet.Filter 接口

代码实现

```java
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		// TODO Auto-generated method stub
        //ServletRequest为HttpServletRequest的父类
        //HttpSession类的session只能被HttpServletRequest类中的getSession()获取,需要提前把ServletRequest类的对象强制转化为HttpServletRequest类
    }
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		
	}
```



#### Filter 的工作流程

![image-20220728222935024](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728222935024.png)

#### 生命周期

1.初始化阶段

Servlet 容器负责加载和实例化 Filter。容器启动时，读取 web.xml 或 @WebFilter 的配置信息对所有的过滤器进行加载和实例化。

加载和实例化完成后，Servlet 容器调用 init() 方法初始化 Filter 实例。在 Filter 的生命周期内， init() 方法只执行一次。

2.拦截和过滤阶段

该阶段是 Filter 生命周期中最重要的阶段。当客户端请求访问 Web 资源时，Servlet 容器会根据 web.xml 或 @WebFilter 的过滤规则进行检查。当客户端请求的 URL 与过滤器映射匹配时，容器将该请求的 request 对象、response 对象以及 FilterChain 对象以参数的形式传递给 Filter 的 doFilter() 方法，并调用该方法对请求/响应进行拦截和过滤。

3.销毁阶段

Filter 对象创建后会驻留在内存中，直到容器关闭或应用被移除时销毁。销毁 Filter 对象之前，容器会先调用 destory() 方法，释放过滤器占用的资源。在 Filter 的生命周期内，destory() 只执行一次。

#### 配置方式

注解、Web.xml

```java
@WebFilter("/pages/cart")  //对/pages/cart路径下的所有页面添加过滤器
@WebFilter("/*")           //对全部路径上的页面添加过滤器
```

#### Filter 链中 Filter 的执行顺序

1. 通过 web.xml 配置的 Filter 过滤器，执行顺序由 \<filter-mapping> 标签的配置顺序决定。\<filter-mapping> 靠前，则 Filter 先执行，靠后则后执行。通过修改 \<filter-mapping> 的顺序便可以修改 Filter 的执行顺序。
2. 通过 @WebFilter 注解配置的 Filter 过滤器，无法进行排序，若需要对 Filter 过滤器进行排序，建议使用 web.xml 进行配置。

#### Filter优点有哪些？ 为什么使用Filter?

1、在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest 。

依据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。

2、在HttpServletResponse到达客户端之前，拦截HttpServletResponse 。

依据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。

Filter解决是多个[Servlet](https://so.csdn.net/so/search?q=Servlet&spm=1001.2101.3001.7020)种所存在的公有的代码[冗余](https://so.csdn.net/so/search?q=冗余&spm=1001.2101.3001.7020)问题，引入Filter之后，把多个Servlet的冗余代码提取到Filter中，那么这样的用户的请求经过Filter,在访问后续的Servlet,既保护用户功能的完成，同时也解决了代码冗余的问题。

## Listener

#### 作用

#### Request, Session, Application

##### 生命周期监听

![image-20220728225422531](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728225422531.png)

##### 属性监听

![image-20220728225430570](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20220728225430570.png)

#### 配置方式 

注解、Web.xml

## Tomcat配置和优化

https://www.cnblogs.com/xuwc/p/8523681.html

## HTML

常用的标签

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>

<link rel="icon" href="static/img/bg.jpg">

</head>
<body>

<img src="static/img/bg.jpg" alt="图片不见了">
<a href="https://www.baidu.com" target="_blank" >百度</a>
<a href="javascript:void(0);">空链接</a>
<a href="javascript:;">空链接</a>
<a href="mailto:">发送邮件</a>   
<div></div>
<span></span> <!-- 仅限于文本 -->

<h1>标题大</h1><h6>小标题</h6>

<p>段落</p>

</body>
</html>
```

三种样式方式

内联样式

```html
<h1 style='color:red'>${soeasy}</h1>
```

引入外部样式

```html
<link rel="stylesheet" href="static/lib/layui/css/layui.css"> 
```

内部样式

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<style type = "text/css">
html {
	background-image: url(static/img/yuan2.webp);
}
	div.loginbox {
		
		/*opacity: 0.3;*/
		background-color: rgba(255,153,153,0.3);
		padding: 40px;
		border: 3px solid green;
		border-radius: 5px;
		position: absolute;
		left: 50%;
		top: 30%;
		transform: translate(-50%,-50%);
		//参照物是第一个	
	}
	div.loginbox label {
		margin-right: 20px;
	}
	div.loginitem {
		margin-bottom: 20px;
	}
	div.butbox {
		text-align: center;	
	}
	div.loginbox input {
		padding: 0 20px 0;
		cursor pointer;
	}
	h3 {
	text-align: center;
	
	}	
</style>
</head>
<body>
	<h3>登录注册界面</h3>
	<div class = "loginbox">
		
		<form action="login" method="post">
		<div class = "loginitem">
		<label>账号</label><input type='text' name="username">
		</div>
		<div class = "loginitem">
		<label>密码</label><input type="password" name="userpass">
		</div>
		<div class = "butbox">
		<input type="submit" value="登录">
		<input type="submit" value="注册">
		</div>
		</form>
	</div>
</body>
</html>

```

## http与https区别

**什么是https和http?**

https是http的安全版本，也叫超文本安全传输，https是有加密传输协议的通道，并且SSL提供了安全加密基础，https主要是用于http的传输，并且在HTTP与TCP之间有一个特殊的加密/身份验证。

http是一种普通的传输协议，在互联网上，所有的文件都要遵守这个HTTP协议，同时超文本也是http传输的基本部分，实现客户端和服务器的相互请求。

**https和http有什么区别**

**![https和http有什么区别](https://img.php.cn/upload/article/000/000/027/5c08ed905d65a464.jpg)**

1、端口

https的端口是443，而http的端口是80，当然两者的连接方式也是不太一样的。

2、传输数据

http传输是明文的，而https是用ssl进行加密的。https具有安全性

3、申请证书

https传输一般是需要申请证书，申请证书可能会需要一定的费用。

而http不需要



### a标签里的 href地址

第一：href=‘javascript:;’

        代表的是发生动作时执行一段javascript代码，但是这个代码是空的，所以什么也不执行

第二：href = ‘’：

        代表的是什么也不执行，但是用这种，动作发生之后，会刷新页面。

第三：href=‘#’：

        代表的同样是什么也不执行，但是用这种，动作发生之后，会自动跳转到页面顶端。
